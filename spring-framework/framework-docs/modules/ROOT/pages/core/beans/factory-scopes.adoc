[[beans-factory-scopes]]
= Bean Scopes

빈(Bean) 정의를 생성할 때, 실제로 해당 빈 정의에 의해 정의된 클래스의 인스턴스를 생성하기 위한 레시피를 만드는 것입니다. 빈 정의가 레시피라는 개념이 중요한 이유는 클래스와 마찬가지로 하나의 레시피로부터 여러 객체 인스턴스를 생성할 수 있다는 것을 의미하기 때문입니다.

특정 빈 정의에서 생성된 객체의 여러 종속성 및 구성 값을 제어할 수 있을 뿐만 아니라 해당 빈 정의에서 생성된 객체의 범위(scope)도 제어할 수 있습니다. 이 접근 방식은 강력하고 유연한데, 특정 빈의 범위(scope)를 Java 클래스 수준에서 하드 코딩해야 하는 대신 설정을 통해 생성하는 객체의 범위(scope)를 선택할 수 있기 때문입니다. 빈은 여러 범위(scope) 중 하나로 정의될 수 있습니다. 스프링 프레임워크는 여섯 가지의 범위(scope)를 지원하며, 그 중 네 가지는 웹 관련 `ApplicationContext` 를 사용할 때만 사용할 수 있습니다. 또한 xref:core/beans/factory-scopes.adoc#beans-factory-scopes-custom[사용자 정의 범위(custom scope)]를 생성할 수도 있습니다.

다음 표는 지원되는 범위(scope)를 설명합니다:

아래는 지원되는 빈 범위(scope)에 대한 정보가 있는 표입니다:

[[beans-factory-scopes-tbl]]
.Bean 범위
[cols="20%,80%"]
|===
| 범위 | 설명

| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-singleton[singleton]
| (기본값) Spring IoC 컨테이너마다 하나의 빈 정의를 하나의 객체 인스턴스에 범위(scope)합니다.

| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-prototype[prototype]
| 하나의 빈 정의를 여러 개의 객체 인스턴스에 범위(scope)합니다.

| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-request[request]
| 하나의 빈 정의를 단일 HTTP 요청의 수명에 범위(scope)합니다. 즉, 각 HTTP 요청은 하나의 빈 정의를 기반으로 자체 인스턴스를 갖습니다. 웹 관련 Spring `ApplicationContext`의 컨텍스트 내에서만 유효합니다.

| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-session[session]
| 하나의 빈 정의를 HTTP `Session`의 수명에 범위(scope)합니다. 웹 관련 Spring `ApplicationContext`의 컨텍스트 내에서만 유효합니다.

| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-application[application]
| 하나의 빈 정의를 `ServletContext`의 수명에 범위(scope)합니다. 웹 관련 Spring `ApplicationContext`의 컨텍스트 내에서만 유효합니다.

| xref:web/websocket/stomp/scope.adoc[websocket]
| 하나의 빈 정의를 `WebSocket`의 수명에 범위(scope)합니다. 웹 관련 Spring `ApplicationContext`의 컨텍스트 내에서만 유효합니다.
|===

NOTE: 스레드 범위(thread scope)는 기본적으로 등록되지 않지만 사용할 수 있습니다. 더 자세한 정보는 {spring-framework-api}/context/support/SimpleThreadScope.html[`SimpleThreadScope`]의 문서를 참조하십시오. 이나 다른 사용자 정의 범위를 등록하는 방법에 대한 지침은 [사용자 정의 범위 사용하기](xref:core/beans/factory-scopes.adoc#beans-factory-scopes-custom-using)를 참조하십시오.


[[beans-factory-scopes-singleton]]
== The Singleton Scope

싱글톤(Singleton) 빈은 하나의 공유된 인스턴스만 관리되며, 해당 빈 정의와 일치하는 ID 또는 여러 ID에 대한 모든 빈 요청은 스프링 컨테이너에서 그 특정 싱글톤 빈 인스턴스를 반환합니다.

다시 말하면, 빈 정의를 정의하고 그것을 싱글톤으로 지정하면, 스프링 IoC 컨테이너는 해당 빈 정의에 의해 정의된 객체의 인스턴스를 정확히 하나 생성합니다. 이 하나의 인스턴스는 싱글톤 빈의 캐시에 저장되며, 그 이름을 가진 빈에 대한 모든 후속 요청과 참조는 캐시된 객체를 반환합니다. 다음 이미지는 싱글톤 범위(scope)가 작동하는 방식을 보여줍니다:

image::singleton.png[]

스프링의 싱글톤 빈 개념은 Gang of Four (GoF) 패턴 책에 정의된 싱글톤 패턴과 다릅니다. GoF 싱글톤 패턴은 객체의 범위(scope)를 하나의 클래스 로더(ClassLoader)당 하나의 특정 클래스 인스턴스로 고정합니다. 스프링의 싱글톤 범위(scope)는 주로 컨테이너(container)와 빈(bean) 당 범위(scope)로 설명됩니다. 이것은 특정 클래스에 대한 빈을 단일 스프링 컨테이너 내에서 정의하는 경우, 스프링 컨테이너가 해당 빈 정의로 정의된 클래스의 단 하나의 인스턴스만을 생성한다는 것을 의미합니다. 싱글톤(scope) 범위는 스프링에서의 기본 범위(scope)입니다.
XML에서 빈을 싱글톤으로 정의하려면 다음 예제와 같이 빈을 정의할 수 있습니다.:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="accountService" class="com.something.DefaultAccountService"/>

	<!-- the following is equivalent, though redundant (singleton scope is the default) -->
	<bean id="accountService" class="com.something.DefaultAccountService" scope="singleton"/>
----



[[beans-factory-scopes-prototype]]
== The Prototype Scope

빈 배치의 싱글톤 범위(scope)이 아닌 프로토타입 범위(scope)는 특정 빈에 대한 요청이 있을 때마다 새로운 빈 인스턴스가 생성됩니다. 즉, 빈은 다른 빈에 주입되거나 컨테이너에서 `getBean()` 메서드를 통해 요청될 때마다 새로운 인스턴스가 생성됩니다. 원칙적으로, 상태를 가지는 빈에는 프로토타입 범위를 사용하고 상태를 가지지 않는 빈에는 싱글톤 범위를 사용해야 합니다.

다음 다이어그램은 Spring 프로토타입 범위(scope)를 설명합니다.:

image::prototype.png[]


(데이터 액세스 객체(DAO)는 일반적으로 프로토타입으로 구성되지 않습니다. 왜냐하면 일반적인 DAO는 대화형 상태를 유지하지 않기 때문입니다. 우리에게는 싱글톤 다이어그램의 핵심을 재사용하는 것이 더 쉬웠습니다.)

The following example defines a bean as a prototype in XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="accountService" class="com.something.DefaultAccountService" scope="prototype"/>
----

다른 범위와는 대조적으로, 스프링은 프로토타입 빈의 전체 라이프사이클을 관리하지 않습니다. 컨테이너는 프로토타입 객체를 인스턴스화하고 구성하며 기타 조립 작업을 수행한 다음 이를 클라이언트에 전달하며 해당 프로토타입 인스턴스에 대한 추가적인 기록을 유지하지 않습니다. 따라서 초기화 라이프사이클 콜백 메서드는 범위와 관계없이 모든 객체에 대해 호출되지만 프로토타입의 경우 구성된 소멸 라이프사이클 콜백은 호출되지 않습니다. 클라이언트 코드는 프로토타입 범위 객체를 정리하고 프로토타입 빈이 보유한 비용이 많이 드는 리소스를 해제해야 합니다. 스프링 컨테이너가 프로토타입 범위 빈이 보유한 리소스를 해제하도록 하려면 정리가 필요한 빈에 대한 참조를 유지하는 [빈 후처리기(bean post-processor)](xref:core/beans/factory-extension.adoc#beans-factory-extension-bpp)를 사용해 보십시오.

어떤 측면에서는 스프링 컨테이너의 역할이 프로토타입 범위 빈에 대한 Java `new` 연산자의 대체로 작용합니다. 이 지점 이후의 모든 라이프사이클 관리는 클라이언트가 처리해야 합니다. (스프링 컨테이너 내에서 빈의 라이프사이클에 대한 자세한 내용은 [라이프사이클 콜백](xref:core/beans/factory-nature.adoc#beans-factory-lifecycle)을 참조하십시오.)



[[beans-factory-scopes-sing-prot-interaction]]
== Singleton Beans with Prototype-bean Dependencies

싱글톤 범위(scope) 빈이 프로토타입 범위 빈에 의존하는 경우, 의존성은 인스턴스화 시점에 해결됨을 인지해야 합니다. 따라서 프로토타입 범위 빈을 싱글톤 범위 빈에 의존성 주입하면 새로운 프로토타입 빈이 인스턴스화되고 그런 다음 싱글톤 빈에 의존성 주입됩니다. 프로토타입 인스턴스는 싱글톤 범위 빈에 제공되는 유일한 인스턴스입니다.

그러나 런타임에서 싱글톤 범위 빈이 반복적으로 프로토타입 범위 빈의 새 인스턴스를 얻어야 하는 경우에는 주의가 필요합니다. 싱글톤 범위 빈에 프로토타입 범위 빈을 의존성으로 주입하는 것은 불가능합니다. 왜냐하면 이 주입은 스프링 컨테이너가 싱글톤 빈을 인스턴스화하고 의존성을 해결하고 주입할 때 단 한 번만 발생하기 때문입니다. 런타임 중에 프로토타입 빈의 새 인스턴스를 여러 번 필요로 하는 경우, [메서드 주입(Method Injection)](xref:core/beans/dependencies/factory-method-injection.adoc)을 참조해야 합니다.



[[beans-factory-scopes-other]]
== Request, Session, Application, and WebSocket Scopes

`request`, `session`, `application`, 그리고 `websocket` 범위(scope)는 웹 인식형 스프링 `ApplicationContext` 구현(예: `XmlWebApplicationContext`)을 사용하는 경우에만 사용할 수 있습니다. 일반적인 Spring IoC 컨테이너인 `ClassPathXmlApplicationContext`와 같은 컨테이너에서 이러한 범위를 사용하면 알 수 없는 빈 범위에 관한 `IllegalStateException` 예외가 발생합니다.


[[beans-factory-scopes-other-web-configuration]]
=== Initial Web Configuration

빈을 `request`, `session`, `application`, 그리고 `websocket` 레벨(web 범위)에서 지원하려면 빈을 정의하기 전에 일부 초기 설정이 필요합니다. (이 초기 설정은 표준 범위인 `singleton`과 `prototype`에는 필요하지 않습니다.)

이 초기 설정은 당신의 특정 서블릿 환경에 따라 어떻게 수행하는지에 따라 다릅니다.

Spring 웹 MVC 내에서 범위가 지정된 빈에 접근하는 경우, 실제로 Spring `DispatcherServlet`에 의해 처리되는 요청 내에서, 별도의 특별한 설정이 필요하지 않습니다. `DispatcherServlet`은 이미 모든 관련 상태를 노출합니다.

만약 Spring의 `DispatcherServlet` 이외의 방법으로 처리되는 요청(예: JSF를 사용할 때)이 있는 Servlet 웹 컨테이너를 사용하는 경우, `org.springframework.web.context.request.RequestContextListener` `ServletRequestListener`를 등록해야 합니다. 이는 `WebApplicationInitializer` 인터페이스를 사용하여 프로그래밍적으로 수행할 수도 있습니다. 또는 웹 애플리케이션의 `web.xml` 파일에 다음 선언을 추가할 수도 있습니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<web-app>
		...
		<listener>
			<listener-class>
				org.springframework.web.context.request.RequestContextListener
			</listener-class>
		</listener>
		...
	</web-app>
----

대안으로, 리스너 설정에 문제가 있는 경우 Spring의 `RequestContextFilter`를 사용하는 것을 고려할 수 있습니다. 
필터 매핑은 주변 웹 애플리케이션 구성에 따라 달라지므로 필요에 맞게 변경해야 합니다. 다음 예제는 웹 애플리케이션의 필터 부분을 보여줍니다.:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<web-app>
		...
		<filter>
			<filter-name>requestContextFilter</filter-name>
			<filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
		</filter>
		<filter-mapping>
			<filter-name>requestContextFilter</filter-name>
			<url-pattern>/*</url-pattern>
		</filter-mapping>
		...
	</web-app>
----

`DispatcherServlet`, `RequestContextListener`, 그리고 `RequestContextFilter`는 모두 동일한 작업을 수행합니다. 즉, HTTP 요청 객체를 해당 요청을 처리하는 `Thread`에 바인딩합니다. 이렇게 하면 요청과 세션 범위의 빈이 호출 체인 아래에서 사용 가능해집니다.



[[beans-factory-scopes-request]]
=== Request scope

Consider the following XML configuration for a bean definition:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="loginAction" class="com.something.LoginAction" scope="request"/>
----

Spring 컨테이너는 각 HTTP 요청에 대해 `loginAction` 빈 정의를 사용하여 `LoginAction` 빈의 새 인스턴스를 생성합니다. 즉, `loginAction` 빈은 HTTP 요청 범위(scope)에 있습니다. 이로 인해 생성된 인스턴스의 내부 상태를 원하는대로 변경할 수 있으며, 동일한 `loginAction` 빈 정의에서 생성된 다른 인스턴스는 상태 변경을 보지 못합니다. 이러한 상태 변경은 개별 요청에 특정합니다. 요청 처리가 완료되면 요청 범위로 지정된 빈은 폐기됩니다.

어노테이션 기반 컴포넌트나 자바 구성을 사용할 때 `@RequestScope` 어노테이션을 사용하여 컴포넌트를 `request` 범위로 할당할 수 있습니다.
다음 예제에서는 어떻게 할 수 있는지 보여줍니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@RequestScope
	@Component
	public class LoginAction {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@RequestScope
	@Component
	class LoginAction {
		// ...
	}
----
======



[[beans-factory-scopes-session]]
=== Session Scope

Consider the following XML configuration for a bean definition:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
----

Spring 컨테이너는 HTTP `Session` 수명 동안 `userPreferences` 빈 정의를 사용하여 `UserPreferences` 빈의 새 인스턴스를 생성합니다. 다시 말해, `userPreferences` 빈은 사실상 HTTP `Session` 범위(scope)에 있습니다. 요청 범위 빈과 마찬가지로 생성된 인스턴스의 내부 상태를 원하는대로 변경할 수 있으며, 동일한 `userPreferences` 빈 정의에서 생성된 다른 HTTP `Session` 인스턴스가 이러한 상태 변경을 보지 못하므로 이러한 변경은 개별 HTTP `Session`에 특정합니다. HTTP `Session`이 최종적으로 폐기될 때 해당 HTTP `Session` 범위로 지정된 빈도 폐기됩니다.

어노테이션 기반 컴포넌트나 자바 구성을 사용할 때 `@SessionScope` 어노테이션을 사용하여 컴포넌트를 `session` 범위로 할당할 수 있습니다.

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@SessionScope
	@Component
	public class UserPreferences {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@SessionScope
	@Component
	class UserPreferences {
		// ...
	}
----
======




[[beans-factory-scopes-application]]
=== Application Scope

Consider the following XML configuration for a bean definition:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="appPreferences" class="com.something.AppPreferences" scope="application"/>
----

Spring 컨테이너는 `appPreferences` 빈 정의를 사용하여 `AppPreferences` 빈의 새 인스턴스를 웹 애플리케이션 전체에 대해 한 번만 생성합니다. 즉, `appPreferences` 빈은 `ServletContext` 범위(scope)에 있으며 일반적인 `ServletContext` 속성으로 저장됩니다. 이는 Spring의 싱글톤 빈과 다소 유사하지만 두 가지 중요한 차이점이 있습니다. 이것은 Spring `ApplicationContext` 당 하나가 아니라 `ServletContext` 당 하나의 싱글톤이며 (한 웹 애플리케이션에서 여러 개가 있을 수 있음), 실제로 `ServletContext` 속성으로 노출되어 볼 수 있습니다.

어노테이션 기반 컴포넌트나 자바 구성을 사용할 때 `@ApplicationScope` 어노테이션을 사용하여 컴포넌트를 `application` 범위로 할당할 수 있습니다. 다음 예제에서는 어떻게 할 수 있는지 보여줍니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	@ApplicationScope
	@Component
	public class AppPreferences {
		// ...
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	@ApplicationScope
	@Component
	class AppPreferences {
		// ...
	}
----
======




[[beans-factory-scopes-websocket]]
=== WebSocket Scope

WebSocket 범위(scope)는 WebSocket 세션의 라이프사이클에 관련이 있으며, WebSocket을 통한 STOMP(Streaming Text Oriented Messaging Protocol) 애플리케이션에 적용됩니다. 자세한 내용은 [WebSocket 범위(WebSocket scope)](xref:web/websocket/stomp/scope.adoc)를 참조하세요.


[[beans-factory-scopes-other-injection]]
=== Scoped Beans as Dependencies

Spring IoC 컨테이너는 객체(빈)의 인스턴스화 뿐만 아니라 협업자(또는 의존성)의 연결(wiring)도 관리합니다. 예를 들어 HTTP 요청 범위 빈을 수명이 더 긴 범위의 다른 빈에 주입하려면 해당 범위 빈 대신 AOP(Aspect-Oriented Programming) 프록시를 주입할 수 있습니다. 즉, 범위 빈과 동일한 공개 인터페이스를 노출하지만 관련 범위(예: HTTP 요청)에서 실제 대상 객체를 검색하고 실제 객체로 메서드 호출을 위임할 수 있는 프록시 객체를 주입해야 합니다.

[NOTE]
====
`<aop:scoped-proxy/>`를 사용하여 `singleton` 범위로 지정된 빈 간에도 중간 프록시를 통과하도록 할 수 있습니다. 이렇게 하면 참조가 직렬화 가능하며 따라서 역직렬화 시에 대상 싱글톤 빈을 다시 얻을 수 있습니다.

또한 범위가 `prototype`로 지정된 빈에 대한 `<aop:scoped-proxy/>`를 선언하면 공유 프록시를 통한 모든 메서드 호출이 호출이 전달될 새 대상 인스턴스의 생성으로 이어집니다.

또한 범위가 짧은 범위에서 빈에 안전하게 액세스하는 방법으로 scoped 프록시가 있는 것이 아닙니다. 주입 지점(즉, 생성자 또는 setter 인자 또는 자동 주입 필드)을 `ObjectFactory<MyTargetBean>`로 선언할 수도 있으며, 이렇게 하면 필요할 때마다 현재 인스턴스를 검색하는 `getObject()` 호출이 가능합니다. 이렇게 하면 인스턴스를 보유하거나 별도로 저장하지 않고도 필요한 때마다 인스턴스를 얻을 수 있습니다.

확장된 변형으로 `ObjectProvider<MyTargetBean>`를 선언할 수도 있으며, 이를 통해 `getIfAvailable` 및 `getIfUnique`를 포함한 여러 가지 추가 액세스 옵션을 제공할 수 있습니다.

이와 관련된 JSR-330 변형은 `Provider`라고 불리며, `Provider<MyTargetBean>` 선언 및 해당 검색 시도마다 `get()` 호출과 함께 사용됩니다. JSR-330에 대한 자세한 내용은 [여기](xref:core/beans/standard-annotations.adoc)에서 확인할 수 있습니다.
====

The configuration in the following example is only one line, but it is important to
understand the "`why`" as well as the "`how`" behind it:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<!-- an HTTP Session-scoped bean exposed as a proxy -->
		<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
			<!-- instructs the container to proxy the surrounding bean -->
			<aop:scoped-proxy/> <1>
		</bean>

		<!-- a singleton-scoped bean injected with a proxy to the above bean -->
		<bean id="userService" class="com.something.SimpleUserService">
			<!-- a reference to the proxied userPreferences bean -->
			<property name="userPreferences" ref="userPreferences"/>
		</bean>
	</beans>
----
<1> The line that defines the proxy.

이러한 프록시를 생성하려면 범위가 지정된 빈 정의에 자식 `<aop:scoped-proxy/>` 요소를 삽입합니다. (자세한 내용은 [프록시 유형 선택](xref:core/beans/factory-scopes.adoc#beans-factory-scopes-other-injection-proxies) 및 [XML 스키마 기반 구성](xref:core/appendix/xsd-schemas.adoc)을 참조하세요.)

왜 `request`, `session`, 그리고 사용자 정의 스코프 수준에서 범위가 지정된 빈의 정의가 공통 시나리오에서 `<aop:scoped-proxy/>` 요소를 필요로 할까요?
다음 싱글톤 빈 정의를 고려하고 이것을 이전에 언급한 스코프에 대한 정의와 비교해 보겠습니다. (다음 `userPreferences` 빈 정의는 현재 불완전한 상태입니다.):

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>

	<bean id="userManager" class="com.something.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

앞의 예에서 싱글톤 빈(`userManager`)은 HTTP `Session` 범위의 빈(`userPreferences`)에 대한 참조를 주입받습니다. 여기서 중요한 점은 `userManager` 빈이 싱글톤인데, 이는 컨테이너 당 한 번만 인스턴스화되며 그 종속성(이 경우에는 `userPreferences` 빈 하나만)도 한 번만 주입됩니다. 이는 `userManager` 빈이 처음 주입된 `userPreferences` 객체와 정확히 동일한 객체(즉, 처음 주입된 객체)에서만 작동한다는 것을 의미합니다.

이것은 짧은 수명의 스코프 빈을 더 긴 수명의 스코프 빈에 주입할 때 원하는 동작이 아닙니다(예: HTTP `Session` 범위의 협업 빈을 싱글톤 빈의 종속성으로 주입). 대신에 하나의 `userManager` 객체가 필요하며 HTTP `Session`의 수명 동안 HTTP `Session`에 특정한 `userPreferences` 객체가 필요합니다. 따라서 컨테이너는 `UserPreferences` 클래스와 정확히 동일한 공개 인터페이스를 노출하는 객체(이상적으로 `UserPreferences` 인스턴스인 객체)를 생성하고, 이 객체는 스코핑 메커니즘(HTTP 요청, `Session` 등)에서 실제 `UserPreferences` 객체를 가져올 수 있어야 합니다. 컨테이너는 이 프록시 객체를 `userManager` 빈에 주입하며, 이 `UserPreferences` 참조가 프록시임을 알지 못합니다. 이 예에서 `UserManager` 인스턴스가 종속성 주입된 `UserPreferences` 객체에서 메서드를 호출할 때 실제로는 프록시에서 메서드를 호출합니다. 프록시는 그런 다음 (이 경우에는) HTTP `Session`에서 실제 `UserPreferences` 객체를 가져와서 메서드 호출을 검색한 실제 `UserPreferences` 객체로 위임합니다.

따라서 협업 객체에 `request-` 및 `session-scoped` 빈을 주입할 때 다음과 같은 (올바르고 완전한) 구성이 필요합니다. 다음 예제에서 보여드립니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
		<aop:scoped-proxy/>
	</bean>

	<bean id="userManager" class="com.something.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

[[beans-factory-scopes-other-injection-proxies]]
==== Choosing the Type of Proxy to Create

By default, when the Spring container creates a proxy for a bean that is marked up with
the `<aop:scoped-proxy/>` element, a CGLIB-based class proxy is created.

[NOTE]
====
CGLIB 프록시는 private 메서드를 가로채지 않습니다. 이러한 프록시에서 private 메서드를 호출하려고 시도하면 실제 범위 대상 객체로 위임되지 않습니다.
====

대안으로 Spring 컨테이너를 구성하여 해당 범위 빈에 대한 표준 JDK 인터페이스 기반 프록시를 생성하도록 할 수 있습니다. 이를 위해 `<aop:scoped-proxy/>` 요소의 `proxy-target-class` 속성 값을 `false`로 설정합니다. JDK 인터페이스 기반 프록시를 사용하면 이러한 프록시를 적용하기 위해 애플리케이션 클래스 경로에 추가 라이브러리가 필요하지 않습니다. 그러나 이것은 해당 범위 빈의 클래스가 적어도 하나의 인터페이스를 구현해야 하고, 해당 범위 빈이 주입되는 모든 협업자는 해당 인터페이스 중 하나를 통해 빈에 참조해야 함을 의미합니다. 다음 예제에서는 인터페이스를 기반으로 한 프록시를 보여줍니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- DefaultUserPreferences implements the UserPreferences interface -->
	<bean id="userPreferences" class="com.stuff.DefaultUserPreferences" scope="session">
		<aop:scoped-proxy proxy-target-class="false"/>
	</bean>

	<bean id="userManager" class="com.stuff.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

For more detailed information about choosing class-based or interface-based proxying,
see xref:core/aop/proxying.adoc[Proxying Mechanisms].



[[beans-factory-scopes-custom]]
== Custom Scopes

빈 범위 메커니즘은 확장 가능합니다. 자신만의 범위를 정의하거나 기존 범위를 다시 정의할 수 있지만, 후자는 권장되지 않는 관행으로 간주되며 내장된 `singleton` 및 `prototype` 범위를 재정의할 수는 없습니다.


[[beans-factory-scopes-custom-creating]]
=== Creating a Custom Scope

Spring 컨테이너에 사용자 정의 범위를 통합하려면 이 섹션에서 설명하는 `org.springframework.beans.factory.config.Scope` 인터페이스를 구현해야 합니다. 자신만의 범위를 구현하는 방법에 대한 아이디어는 Spring Framework 자체와 함께 제공되는 `Scope` 구현 및 `{spring-framework-api}/beans/factory/config/Scope.html[`Scope`]` 자바독을 참조하면 됩니다. 이 자바독에서는 더 자세히 구현해야 하는 메서드에 대한 설명이 포함되어 있습니다.

`Scope` 인터페이스에는 범위에서 객체를 가져오고 범위에서 제거하며 객체를 파괴하는 네 가지 메서드가 있습니다.

예를 들어 세션 범위 구현은 세션 범위의 빈을 반환합니다(빈이 존재하지 않으면 미래 참조를 위해 세션에 빈을 바인딩한 후 새 인스턴스를 반환합니다). 다음 메서드는 기본 범위에서 객체를 반환합니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	Object get(String name, ObjectFactory<?> objectFactory)
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	fun get(name: String, objectFactory: ObjectFactory<*>): Any
----
======

세션 범위 구현은 세션 범위의 빈을 기본 세션에서 제거합니다. 객체를 반환해야 하지만 지정된 이름의 객체를 찾을 수 없는 경우 `null`을 반환할 수 있습니다. 다음 메서드는 기본 범위에서 객체를 제거합니다.:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	Object remove(String name)
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	fun remove(name: String): Any
----
======

The following method registers a callback that the scope should invoke when it is
destroyed or when the specified object in the scope is destroyed:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	void registerDestructionCallback(String name, Runnable destructionCallback)
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	fun registerDestructionCallback(name: String, destructionCallback: Runnable)
----
======

See the {spring-framework-api}/beans/factory/config/Scope.html#registerDestructionCallback[javadoc]
or a Spring scope implementation for more information on destruction callbacks.

The following method obtains the conversation identifier for the underlying scope:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	String getConversationId()
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	fun getConversationId(): String
----
======

This identifier is different for each scope. For a session scoped implementation, this
identifier can be the session identifier.



[[beans-factory-scopes-custom-using]]
=== Using a Custom Scope

하나 이상의 사용자 정의 `Scope` 구현을 작성하고 테스트한 후에는 Spring 컨테이너가 새로운 스코프를 인식하도록 설정해야 합니다. 다음 메서드는 Spring 컨테이너에 새로운 `Scope`를 등록하는 중요한 메서드입니다.:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	void registerScope(String scopeName, Scope scope);
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	fun registerScope(scopeName: String, scope: Scope)
----
======

이 메서드는 대부분의 Spring과 함께 제공되는 구체적인 `ApplicationContext` 구현체에서 제공되는 `BeanFactory` 속성을 통해 사용할 수 있는 `ConfigurableBeanFactory` 인터페이스에 선언되어 있습니다.

`registerScope(..)` 메서드의 첫 번째 인수는 스코프와 연결된 고유한 이름입니다. Spring 컨테이너 내에서 이와 같은 이름의 예시는 `singleton` 및 `prototype`입니다. `registerScope(..)` 메서드의 두 번째 인수는 등록하고 사용하려는 사용자 정의 `Scope` 구현의 실제 인스턴스입니다.

사용자 정의 `Scope` 구현을 작성하고 다음 예제에 표시된대로 등록한다고 가정해 보겠습니다.

NOTE: 다음 예제에서는 Spring과 함께 제공되지만 기본적으로 등록되지 않는 `SimpleThreadScope`를 사용합니다. 동일한 지침은 사용자 정의 `Scope` 구현에 대해서도 적용됩니다.

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	Scope threadScope = new SimpleThreadScope();
	beanFactory.registerScope("thread", threadScope);
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	val threadScope = SimpleThreadScope()
	beanFactory.registerScope("thread", threadScope)
----
======

You can then create bean definitions that adhere to the scoping rules of your custom
`Scope`, as follows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="..." class="..." scope="thread">
----


사용자 정의 Scope 구현으로는 스코프의 프로그래밍 등록에만 국한되지 않습니다. CustomScopeConfigurer 클래스를 사용하여 스코프 등록을 선언적으로 수행할 수도 있습니다. 다음 예제에서처럼요:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">
			<property name="scopes">
				<map>
					<entry key="thread">
						<bean class="org.springframework.context.support.SimpleThreadScope"/>
					</entry>
				</map>
			</property>
		</bean>

		<bean id="thing2" class="x.y.Thing2" scope="thread">
			<property name="name" value="Rick"/>
			<aop:scoped-proxy/>
		</bean>

		<bean id="thing1" class="x.y.Thing1">
			<property name="thing2" ref="thing2"/>
		</bean>

	</beans>
----

NOTE: `<aop:scoped-proxy/>`를 `FactoryBean` 구현체의 `<bean>` 선언 내에 배치할 경우, 스코프가 반환된 `getObject()`에서가 아니라 팩토리 빈 자체에 적용됩니다..



