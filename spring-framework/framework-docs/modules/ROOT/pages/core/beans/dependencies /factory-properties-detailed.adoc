[[beans-factory-properties-detailed]]
= Dependencies and Configuration in Detail

이전 섹션에서 언급한 대로, 빈의 속성과 생성자 인수를 다른 관리되는 빈(협력자)을 참조하거나 인라인으로 정의된 값으로 정의할 수 있습니다. Spring의 XML 기반 구성 메타데이터는 이 목적을 위해 `<property/>` 및 `<constructor-arg/>` 요소 내에서 하위 요소 유형을 지원합니다.

[[beans-value-element]]
== Straight Values (Primitives, Strings, and so on)

`<property/>` 요소의 `value` 속성은 속성이나 생성자 인수를 인간이 읽을 수 있는 문자열 표현으로 지정합니다. 
Spring의 변환 서비스를 사용하여 이러한 값을 `String`에서 속성 또는 인수의 실제 유형으로 변환합니다. 
다음 예제는 다양한 값을 설정하는 방법을 보여줍니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<!-- results in a setDriverClassName(String) call -->
		<property name="driverClassName" value="com.mysql.jdbc.Driver"/>
		<property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
		<property name="username" value="root"/>
		<property name="password" value="misterkaoli"/>
	</bean>
----

다음 예제에서는 더 간결한 XML 구성을 위해 xref:core/beans/dependencies/factory-properties-detailed.adoc#beans-p-namespace[p-namespace] 을 사용합니다.
XML configuration:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
			destroy-method="close"
			p:driverClassName="com.mysql.jdbc.Driver"
			p:url="jdbc:mysql://localhost:3306/mydb"
			p:username="root"
			p:password="misterkaoli"/>

	</beans>
----

앞서 나온 XML은 더 간결하지만, 오타는 설계 시간이 아니라 런타임에서 발견됩니다. 단, 빈 정의를 생성할 때 자동 속성 완성을 지원하는 https://www.jetbrains.com/idea/[IntelliJ IDEA]나 https://spring.io/tools[Spring Tools for Eclipse]와 같은 IDE를 사용하는 경우에는 런타임이 아니라 설계 시간에도 오타를 발견할 수 있습니다. 이러한 IDE 지원은 강력히 권장됩니다.

You can also configure a `java.util.Properties` instance, as follows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="mappings"
		class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">

		<!-- typed as a java.util.Properties -->
		<property name="properties">
			<value>
				jdbc.driver.className=com.mysql.jdbc.Driver
				jdbc.url=jdbc:mysql://localhost:3306/mydb
			</value>
		</property>
	</bean>
----

Spring 컨테이너는 JavaBeans `PropertyEditor` 메커니즘을 사용하여 `<value/>` 요소 내부의 텍스트를 `java.util.Properties` 인스턴스로 변환합니다. 이것은 유용한 바로 가기이며, Spring 팀이 `value` 속성 스타일 대신 중첩된 `<value/>` 요소를 선호하는 몇 군데 중 하나입니다.

[[beans-idref-element]]
=== The `idref` element

`idref` 요소는 컨테이너 내의 다른 빈의 `id` (참조가 아닌 문자열 값)을 `<constructor-arg/>` 또는 `<property/>` 요소로 전달하는 방법 중 하나로, 오류를 방지하기 위한 간단한 방법입니다. 다음 예제에서는 이를 어떻게 사용하는지 보여줍니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="theTargetBean" class="..."/>

	<bean id="theClientBean" class="...">
		<property name="targetName">
			<idref bean="theTargetBean"/>
		</property>
	</bean>
----

앞의 빈 정의 스니펫은 (실행 시간에) 다음과 정확히 동등합니다.
following snippet:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="theTargetBean" class="..." />

	<bean id="client" class="...">
		<property name="targetName" value="theTargetBean"/>
	</bean>
----

첫 번째 형태가 두 번째 형태보다 선호되는 이유는 `idref` 태그를 사용하면 컨테이너가 참조된 이름이 지정한 빈이 실제로 존재하는지 배포 시간에 유효성을 검사할 수 있기 때문입니다. 두 번째 형태에서는 `client` 빈의 `targetName` 속성에 전달되는 값에 대한 유효성 검사가 수행되지 않습니다. 오타는 `client` 빈이 실제로 인스턴스화될 때만 발견됩니다(대부분 치명적인 결과를 초래할 가능성이 높음). 만약 `client` 빈이 xref:core/beans/factory-scopes.adoc[프로토타입] 빈인 경우, 이러한 오타와 그에 따른 예외는 컨테이너가 배포된 후에 오랜 시간이 지난 뒤에만 발견될 수 있습니다.

참고: 4.0 빈 XSD에서는 `idref` 요소의 `local` 속성이 더 이상 지원되지 않으며, 더 이상 보편적인 `bean` 참조보다 추가 가치를 제공하지 않습니다. 4.0 스키마로 업그레이드할 때 기존의 `idref local` 참조를 `idref bean`으로 변경하십시오.

`ProxyFactoryBean` 빈 정의에서 xref:core/aop-api/pfb.adoc#aop-pfb-1[AOP 인터셉터]를 구성할 때 `<idref/>` 요소가 가치를 제공하는 공통한 장소는 (적어도 Spring 2.0 이전 버전에서) 인터셉터 ID를 잘못 입력하는 것을 방지하는 데 사용됩니다.


[[beans-ref-element]]
== References to Other Beans (Collaborators)

`<ref/>` 요소는 `<constructor-arg/>` 또는 `<property/>` 정의 요소 내부의 마지막 요소입니다. 여기서 빈의 지정된 속성 값을 컨테이너에서 관리하는 다른 빈(협력자)에 대한 참조로 설정합니다. 참조된 빈은 속성을 설정하기 전에 필요한 경우 빈의 종속성이며, 속성을 설정하기 전에 필요한 경우 초기화됩니다(협력자가 싱글톤 빈인 경우 이미 컨테이너에서 초기화될 수 있음). 모든 참조는 궁극적으로 다른 객체에 대한 참조입니다. 범위 및 유효성 검사는 `bean` 또는 `parent` 속성을 통해 다른 객체의 ID 또는 이름을 지정하는 방법에 따라 달라집니다.

`<ref/>` 태그의 `bean` 속성을 통해 대상 빈을 지정하는 것은 가장 일반적인 형태로, 동일한 컨테이너 또는 부모 컨테이너 내에서 XML 파일이 동일한 여부에 관계없이 동일한 컨테이너 또는 부모 컨테이너 내의 어떤 빈에 대한 참조를 생성할 수 있습니다. `bean` 속성의 값은 대상 빈의 `id` 속성과 동일하거나 대상 빈의 `name` 속성 값 중 하나와 동일할 수 있습니다. 다음 예제는 `ref` 요소를 사용하는 방법을 보여줍니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<ref bean="someBean"/>
----

`parent` 속성을 통해 대상 빈을 지정하면 현재 컨테이너의 부모 컨테이너에 있는 빈에 대한 참조를 생성합니다. 
`parent` 속성의 값은 대상 빈의 `id` 속성 또는 대상 빈의 `name` 속성 값 중 하나와 동일할 수 있습니다.
대상 빈은 현재 컨테이너의 부모 컨테이너에 있어야 합니다. 이 빈 참조 변형은 주로 컨테이너의 계층 구조가 있고 부모 컨테이너에 있는 기존 빈을 동일한 이름을 가진 부모 빈을 갖는 프록시로 래핑하려는 경우에 사용해야 합니다. 다음 두 코드 예제는 `parent` 속성을 사용하는 방법을 보여줍니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- in the parent context -->
	<bean id="accountService" class="com.something.SimpleAccountService">
		<!-- insert dependencies as required here -->
	</bean>
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- in the child (descendant) context -->
	<bean id="accountService" <!-- bean name is the same as the parent bean -->
		class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="target">
			<ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
		</property>
		<!-- insert other configuration and dependencies as required here -->
	</bean>
----

NOTE: The `local` attribute on the `ref` element is no longer supported in the 4.0 beans
XSD, since it does not provide value over a regular `bean` reference any more. Change
your existing `ref local` references to `ref bean` when upgrading to the 4.0 schema.


[[beans-inner-beans]]
== Inner Beans

A `<bean/>` element inside the `<property/>` or `<constructor-arg/>` elements defines an
inner bean, as the following example shows:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="outer" class="...">
		<!-- instead of using a reference to a target bean, simply define the target bean inline -->
		<property name="target">
			<bean class="com.example.Person"> <!-- this is the inner bean -->
				<property name="name" value="Fiona Apple"/>
				<property name="age" value="25"/>
			</bean>
		</property>
	</bean>
----

내부 빈 정의는 정의된 ID나 이름이 필요하지 않습니다. 지정된 경우 컨테이너는 해당 값을 식별자로 사용하지 않습니다. 또한 컨테이너는 생성 시 `scope` 플래그를 무시합니다. 왜냐하면 내부 빈은 항상 익명이며 항상 외부 빈과 함께 생성되기 때문입니다. 내부 빈에 독립적으로 액세스하거나 그것들을 외부 빈 이외의 협력 빈에 주입하는 것은 불가능합니다. 

한 가지 특별한 경우로, 사용자 정의 스코프에서 파생된 파괴(callback) 콜백을 받을 수 있습니다. 예를 들어 싱글톤 빈 내부에 포함된 요청 범위 내부 빈의 경우입니다. 내부 빈 인스턴스의 생성은 포함 빈에 연결되지만, 파괴(callback) 콜백을 통해 요청 범위의 라이프사이클에 참여할 수 있습니다. 이것은 일반적인 시나리오가 아닙니다. 내부 빈은 일반적으로 포함 빈의 스코프를 공유합니다.


[[beans-collection-elements]]
== Collections

The `<list/>`, `<set/>`, `<map/>`, and `<props/>` elements set the properties
and arguments of the Java `Collection` types `List`, `Set`, `Map`, and `Properties`,
respectively. The following example shows how to use them:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="moreComplexObject" class="example.ComplexObject">
		<!-- results in a setAdminEmails(java.util.Properties) call -->
		<property name="adminEmails">
			<props>
				<prop key="administrator">administrator@example.org</prop>
				<prop key="support">support@example.org</prop>
				<prop key="development">development@example.org</prop>
			</props>
		</property>
		<!-- results in a setSomeList(java.util.List) call -->
		<property name="someList">
			<list>
				<value>a list element followed by a reference</value>
				<ref bean="myDataSource" />
			</list>
		</property>
		<!-- results in a setSomeMap(java.util.Map) call -->
		<property name="someMap">
			<map>
				<entry key="an entry" value="just some string"/>
				<entry key="a ref" value-ref="myDataSource"/>
			</map>
		</property>
		<!-- results in a setSomeSet(java.util.Set) call -->
		<property name="someSet">
			<set>
				<value>just some string</value>
				<ref bean="myDataSource" />
			</set>
		</property>
	</bean>
----

The value of a map key or value, or a set value, can also be any of the
following elements:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	bean | ref | idref | list | set | map | props | value | null
----

[[beans-collection-elements-merging]]
=== Collection Merging

Spring 컨테이너는 컬렉션 병합도 지원합니다. 애플리케이션 개발자는 부모 `<list/>`, `<map/>`, `<set/>`, 또는 `<props/>` 요소를 정의하고 자식 `<list/>`, `<map/>`, `<set/>`, 또는 `<props/>` 요소가 부모 컬렉션에서 값을 상속하고 재정의하도록 할 수 있습니다. 즉, 자식 컬렉션의 값은 부모 컬렉션과 자식 컬렉션의 요소를 병합한 결과로, 자식 컬렉션의 요소는 부모 컬렉션에서 지정된 값에 재정의됩니다.

이 병합에 대한 섹션은 부모-자식 빈 메커니즘을 다룹니다. 부모와 자식 빈 정의에 익숙하지 않은 독자는 계속하기 전에 관련 섹션을 읽는 것이 좋습니다. 아래의 예제는 컬렉션 병합을 보여줍니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="parent" abstract="true" class="example.ComplexObject">
			<property name="adminEmails">
				<props>
					<prop key="administrator">administrator@example.com</prop>
					<prop key="support">support@example.com</prop>
				</props>
			</property>
		</bean>
		<bean id="child" parent="parent">
			<property name="adminEmails">
				<!-- the merge is specified on the child collection definition -->
				<props merge="true">
					<prop key="sales">sales@example.com</prop>
					<prop key="support">support@example.co.uk</prop>
				</props>
			</property>
		</bean>
	<beans>
----

`child` 빈 정의의 `adminEmails` 속성의 `<props/>` 요소에 있는 `merge=true` 속성을 주목하세요. 컨테이너가 `child` 빈을 해결하고 인스턴스화할 때, 결과 인스턴스에는 자식의 `adminEmails` 컬렉션을 부모의 `adminEmails` 컬렉션과 병합한 결과가 포함된 `Properties` 컬렉션이 있습니다. 아래 코드는 결과를 보여줍니다:

[literal,subs="verbatim,quotes"]
----
administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk
----

자식 `Properties` 컬렉션의 값 집합은 부모 `<props/>`에서 모든 property 요소를 상속받으며, 자식의 `support` 값은 부모 컬렉션의 값에 재정의됩니다.

이러한 병합 동작은 `<list/>`, `<map/>`, 및 `<set/>` 컬렉션 유형에 대해서도 유사하게 적용됩니다. 특히 `<list/>` 요소의 경우 `List` 컬렉션 유형과 관련된 의미론(즉, `ordered` 값의 컬렉션 개념)이 유지됩니다. 부모의 값은 모든 자식 리스트의 값 앞에 나옵니다. 반면에 `Map`, `Set`, 및 `Properties` 컬렉션 유형의 경우 순서가 없습니다. 따라서 컨테이너가 내부적으로 사용하는 관련 `Map`, `Set`, 및 `Properties` 구현 유형에 대한 컬렉션 유형에 대한 순서 의미론은 적용되지 않습니다.

[[beans-collection-merge-limitations]]
=== Limitations of Collection Merging

다른 컬렉션 유형(예: `Map` 및 `List`)을 병합할 수 없습니다. 이렇게 시도하면 적절한 예외가 발생합니다. `merge` 속성은 상속된 하위 자식 정의에서 지정해야 합니다. 부모 컬렉션 정의에 `merge` 속성을 지정하는 것은 중복되며 원하는 병합 결과를 얻을 수 없습니다.

[[beans-collection-elements-strongly-typed]]
=== Strongly-typed collection

Java의 제네릭 타입 지원 덕분에 강력한 형식화된 컬렉션을 사용할 수 있습니다. 즉, `Collection` 유형을 선언하여 (예: `String` 요소만 포함 가능한) 특정 타입의 요소만 포함될 수 있도록 할 수 있습니다. Spring을 사용하여 강력한 형식화된 `Collection`을 빈에 주입하면 Spring의 타입 변환 지원을 활용하여 강력한 형식화된 `Collection` 인스턴스의 요소가 컬렉션에 추가되기 전에 적절한 타입으로 변환됩니다. 다음의 Java 클래스와 빈 정의는 이를 어떻게 수행하는지 보여줍니다:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	public class SomeClass {

		private Map<String, Float> accounts;

		public void setAccounts(Map<String, Float> accounts) {
			this.accounts = accounts;
		}
	}
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
class SomeClass {
	lateinit var accounts: Map<String, Float>
}
----
======

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="something" class="x.y.SomeClass">
			<property name="accounts">
				<map>
					<entry key="one" value="9.99"/>
					<entry key="two" value="2.75"/>
					<entry key="six" value="3.99"/>
				</map>
			</property>
		</bean>
	</beans>
----

`something` 빈의 `accounts` 속성이 주입 준비될 때, 강력한 형식화된 `Map<String, Float>`의 요소 유형에 대한 제네릭 정보가 리플렉션을 통해 사용 가능합니다. 따라서 Spring의 타입 변환 인프라는 다양한 값 요소를 `Float` 타입으로 인식하고 문자열 값(`9.99`, `2.75`, `3.99`)이 실제 `Float` 타입으로 변환됩니다.


[[beans-null-element]]
== Null and Empty String Values

Spring은 속성과 같은 빈에 대한 빈 인자가 비어있는 경우를 빈 문자열("")로 처리합니다. 다음과 같은 XML 기반 구성 메타데이터 스니펫은 `email` 속성을 빈 문자열("") 값으로 설정합니다.

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="ExampleBean">
		<property name="email" value=""/>
	</bean>
----

The preceding example is equivalent to the following Java code:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	exampleBean.setEmail("");
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	exampleBean.email = ""
----
======


The `<null/>` element handles `null` values. The following listing shows an example:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="ExampleBean">
		<property name="email">
			<null/>
		</property>
	</bean>
----

The preceding configuration is equivalent to the following Java code:

[tabs]
======
Java::
+
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
----
	exampleBean.setEmail(null);
----

Kotlin::
+
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
	exampleBean.email = null
----
======


[[beans-p-namespace]]
== XML Shortcut with the p-namespace

p-네임스페이스를 사용하면 `<property/>` 요소의 중첩 대신 `bean` 요소의 속성을 사용하여 속성 값을 정의하거나 협력 빈을 설명할 수 있습니다.

Spring은 XML 스키마 정의를 기반으로 한 xref:core/appendix/xsd-schemas.adoc[네임스페이스를 사용한] 확장 가능한 구성 형식을 지원합니다. 이 장에서 다루는 `beans` 구성 형식은 XML 스키마 문서에 정의되어 있습니다. 그러나 p-네임스페이스는 XSD 파일에 정의되어 있지 않으며 Spring의 핵심 부분에서만 사용할 수 있습니다.

다음 예제는 두 개의 XML 스니펫을 보여줍니다 (첫 번째는 표준 XML 형식을 사용하고 두 번째는 p-네임스페이스를 사용합니다). 이 두 예제는 동일한 결과를 얻습니다.

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean name="classic" class="com.example.ExampleBean">
			<property name="email" value="someone@somewhere.com"/>
		</bean>

		<bean name="p-namespace" class="com.example.ExampleBean"
			p:email="someone@somewhere.com"/>
	</beans>
----

이 예제에서는 빈 정의에서 p-네임스페이스의 `email`이라는 속성을 보여줍니다. 이것은 Spring에게 속성 선언을 포함하도록 지시하는 것입니다. 앞서 언급한대로 p-네임스페이스에는 스키마 정의가 없으므로 속성 이름을 속성 이름으로 설정할 수 있습니다.

다음 예제에는 다른 빈에 대한 참조를 가진 두 개의 빈 정의가 더 포함되어 있습니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean name="john-classic" class="com.example.Person">
			<property name="name" value="John Doe"/>
			<property name="spouse" ref="jane"/>
		</bean>

		<bean name="john-modern"
			class="com.example.Person"
			p:name="John Doe"
			p:spouse-ref="jane"/>

		<bean name="jane" class="com.example.Person">
			<property name="name" value="Jane Doe"/>
		</bean>
	</beans>
----

이 예제는 p-네임스페이스를 사용하여 속성 값뿐만 아니라 속성 참조를 선언하는 특별한 형식도 포함하고 있습니다. 첫 번째 빈 정의에서는 빈 `john`에서 빈 `jane`으로의 참조를 만들기 위해 `<property name="spouse" ref="jane"/>`를 사용하는 반면, 두 번째 빈 정의에서는 동일한 작업을 수행하는 데 `p:spouse-ref="jane"`를 속성으로 사용합니다. 이 경우 `spouse`는 속성 이름이며 `-ref` 부분은 이것이 직접적인 값이 아닌 다른 빈에 대한 참조임을 나타냅니다.

참고: p-네임스페이스는 표준 XML 형식만큼 유연하지 않습니다. 예를 들어, 속성 이름이 `Ref`로 끝나는 경우 속성 참조를 선언하는 형식이 충돌할 수 있지만 표준 XML 형식은 그렇지 않습니다. 동시에 세 가지 접근 방식을 사용하는 XML 문서를 생성하지 않도록 주의하고 팀원들과 이를 의사소통하는 것이 좋습니다.


[[beans-c-namespace]]
== XML Shortcut with the c-namespace

p-네임스페이스의 xref:core/beans/dependencies/factory-properties-detailed.adoc#beans-p-namespace[XML 단축키와 유사하게], Spring 3.1에서 소개된 c-네임스페이스는 중첩된 `constructor-arg` 요소 대신 생성자 인자를 구성하기 위한 인라인 속성을 허용합니다.

다음 예제는 `c:` 네임스페이스를 사용하여 xref:core/beans/dependencies/factory-collaborators.adoc#beans-constructor-injection[생성자 기반 의존성 주입]에서 수행하는 것과 동일한 작업을 수행합니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:c="http://www.springframework.org/schema/c"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="beanTwo" class="x.y.ThingTwo"/>
		<bean id="beanThree" class="x.y.ThingThree"/>

		<!-- traditional declaration with optional argument names -->
		<bean id="beanOne" class="x.y.ThingOne">
			<constructor-arg name="thingTwo" ref="beanTwo"/>
			<constructor-arg name="thingThree" ref="beanThree"/>
			<constructor-arg name="email" value="something@somewhere.com"/>
		</bean>

		<!-- c-namespace declaration with argument names -->
		<bean id="beanOne" class="x.y.ThingOne" c:thingTwo-ref="beanTwo"
			c:thingThree-ref="beanThree" c:email="something@somewhere.com"/>

	</beans>
----

`c:` 네임스페이스는 생성자 인자를 이름으로 설정하기 위해 `p:`와 동일한 규칙을 사용합니다 (빈 참조에 대한 `-ref`가 뒤에 붙음). 마찬가지로 이를 XML 파일에 선언해야 하지만 XSD 스키마에 정의되어 있지 않습니다 (Spring 코어 내에 존재합니다).

생성자 인자 이름이 사용 불가능한 희귀한 경우 (보통 디버깅 정보를 포함하지 않고 바이트코드를 컴파일한 경우), 다음과 같이 인수 인덱스로 대체할 수 있습니다:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- c-namespace index declaration -->
	<bean id="beanOne" class="x.y.ThingOne" c:_0-ref="beanTwo" c:_1-ref="beanThree"
		c:_2="something@somewhere.com"/>
----

참고: XML 문법으로 인해 인덱스 표기법은 선행 `_`의 존재를 요구합니다. XML 속성 이름은 숫자로 시작할 수 없기 때문입니다 (일부 IDE에서는 허용되지만). `<constructor-arg>` 요소에 대한 대응하는 인덱스 표기법도 있지만 일반적으로 선언 순서만으로 충분하기 때문에 일반적으로 사용되지 않습니다.

실제로 생성자 해결 xref:core/beans/dependencies/factory-collaborators.adoc#beans-factory-ctor-arguments-resolution[메커니즘]은 인수를 일치시키는 데 매우 효율적이므로 필요하지 않는 경우에는 구성 전체에서 이름 표기법을 사용하는 것을 권장합니다.


[[beans-compound-property-names]]
== Compound Property Names

빈 속성을 설정할 때 마지막 속성 이름을 제외한 경로의 모든 구성 요소가 `null`이 아닌 한 복합 또는 중첩된 속성 이름을 사용할 수 있습니다. 다음과 같은 빈 정의를 고려해보세요:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="something" class="things.ThingOne">
		<property name="fred.bob.sammy" value="123" />
	</bean>
----

`something` 빈은 `fred` 속성을 가지고 있으며 이 속성은 `bob` 속성을 가지고 있고, 그 `bob` 속성은 `sammy` 속성에 값을 `123`으로 설정하고 있습니다. 이 작업을 수행하기 위해서는 `something`의 `fred` 속성과 `fred`의 `bob` 속성이 빈이 생성된 후에 `null`이 아니어야 합니다. 그렇지 않으면 `NullPointerException`이 발생합니다.


